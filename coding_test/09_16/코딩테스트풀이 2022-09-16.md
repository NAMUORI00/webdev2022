# 코딩테스트 정리

코딩테스트 입문용 1레벨 간단한 문제 풀이

![스크린샷 2022-09-15 오전 10.38.57.png](2022-09-16/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-09-15_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_10.38.57.png)



![](2022-09-16/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-09-15_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_10.45.12.png)



> 과제로 제출하기엔 너무 난이도 부분에 민망한 부분이 있어 적어도 2레벨 문제를 풀어야 할 것이기에 이렇게 풀었다 정도로만 이미지를 첨부해본다.



## 과제용 2레벨 문제 풀이



### **문제 설명**

정수 `n`, `left`, `right`가 주어집니다. 다음 과정을 거쳐서 1차원 배열을 만들고자 합니다.

1. `n`행 `n`열 크기의 비어있는 2차원 배열을 만듭니다.
2. `i = 1, 2, 3, ..., n`에 대해서, 다음 과정을 반복합니다.
    - 1행 1열부터 `i`행 `i`열까지의 영역 내의 모든 빈 칸을 숫자 `i`로 채웁니다.
3. 1행, 2행, ..., `n`행을 잘라내어 모두 이어붙인 새로운 1차원 배열을 만듭니다.
4. 새로운 1차원 배열을 `arr`이라 할 때, `arr[left]`, `arr[left+1]`, ..., `arr[right]`만 남기고 나머지는 지웁니다.

정수 `n`, `left`, `right`가 매개변수로 주어집니다. 주어진 과정대로 만들어진 1차원 배열을 return 하도록 solution 함수를 완성해주세요.



- 첫번째 문제 풀이 코드

```python
def solution(n, left, right):
    temp_matrix = [[0 for x in range(1,n+1)] for y in range(n)]
    
    for i in range(n):
        for j in range(i+1):
            temp_matrix[i][j] = i+1
    for i in range(n):
        for j in range(i+1):
            temp_matrix[j][i] = i+1
    
    temp_arry = sum(temp_matrix,[])
    result = temp_arry
    return result[left:right+1]
```



**이렇게 풀이한 이유 :** 

1. 2차원 배열을 생성하고, 과정을 반복하라는 문구를 발견
2. 2중 for문을 이용해야 할거라 해석 하였다
3. 문제 (1, 2, 3, 4) 지문의 요구에 따라 for문을 이중으로 돌려 matrix를 생성
4. 이것을 1차원 배열 구조로 바꾸고, left, right 값의 범위값을 받아서 
5. 요구에 맞게 출력하도록 코드를 짜서 제출했다.

![Untitled](2022-09-16/Untitled.png)



**결과** : 코드 실행으로는 정상 작동하나, 제출후 최종 테스트에서는 조건에따라 시간초과가 걸리게 되어서, 실패가 되었다.

수정해야할 부분 : 논리적으로는 동작하게 되었으나 좀더 중간과정을 생략하여 빠르게 결과값을 나오게 코드를 짜야함



### 수정하여 제출한 코드

```python
def solution(n, left, right):
    answer = []

    for i in range(left, right+1):
        temp_i = i // n
        temp_j = i % n
        result = max(temp_i, temp_j)+1
        answer.append(result)
;
    return answer
```

> 2차원 배열을 생성할 필요도 없이, 결과 값의 **각 자리의 숫자는 행과 열중 더 큰 값을 가진 것의 인덱스값 + 1** 인 구조를 가지는것을 알 수 있었고, 이에 따라 matrix를 생성하는 코드를 생략하면서, 규칙에 따라 결과 값이 나오도록 수정하였다.



![화면 캡처 2022-09-16 191411.png](2022-09-16/%25ED%2599%2594%25EB%25A9%25B4_%25EC%25BA%25A1%25EC%25B2%2598_2022-09-16_191411.png)



![스크린샷 2022-09-16 오후 4.04.33.png](2022-09-16/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-09-16_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.04.33.png)

> 요약 : 제한사항의 10^7 의 어마어마하게 큰 값이 포함되어있어서 이중 for문은 이를 처리하기에 너무 많은 시간이 걸린다, 따라서 결과값이 생기는 규칙을 찾는것이 중요한 문제로 보인다.