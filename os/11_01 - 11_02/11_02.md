# CPU 스케줄링

1. 스케줄링의 개요
2. 스케줄링 시 고려 사항
3. 다중 큐
4. 스케줄링 알고리즘
5. 인터럽트 처리



## CPU, 스케줄링



### CPU 스케줄러

---

- 운영체제에게 식당관리자 처럼 업무 배분을 담당
- 프로세스의 상황을 고려하여 CPU와 시스템 자원을 배정할지 결정하는일을 담당

<img src="11-01\스크린샷_2022-03-28_오후_5.23.54.png" alt="스크린샷_2022-03-28_오후_5.23.54" style="zoom:33%;" />

- 고수준 스케줄링(long term scheduling)
    - 시스템 내의 전체 작업 수를 조절하는 것
    - 어떤 작업을 시스템이 받아들일지 또는 거부할지를 결정
    - 시스템 내에서 동시에 실행 가능한 프로세스의 중개수가 정해짐
    - 장기 스케줄링, 작업 스케줄링, 승인 스케줄링 이라고도 함

- 저수준 스케줄링(short term scheduling)
    - 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정
    - 아주 짧은 시간에 일어나기 때문에 단기 스케줄링 이라고도 함

- 중간 수준 스케줄링
    - 중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막음
    - 일부 프로세스를 중지 상태로 옮김으로 나머지 프로세스가 원만하게 작동하도록 지원
    - 저수준 스케줄링이 원만하게 이루어지도록 완충하는 역할



### CPU 스케줄링 목적

- 공평성
    - 모든 프로세스가 자원을 공평하게 배정받아야함, 특정 프로세스가 배제되어선 안됨
- 효율성
    - 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링 하고 유휴 자원을 사용하는 프로세스에는 우선권을 주어야함
- 안정성
    - 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로, 시스템 자원을 점유하거나 파괴하려는 프로세스로 부터 자원을 보호해야함
- 확장성
    - 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치해야 함. 시스템 자원이 늘어나는 경우 이 혜택이 시스템에 반영되게 해야함
- 반응 시간 보장
    - 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간안에 프로세스의 요구에 반응해야함
- 무한 연기 방지
    - 특정 프로세스의 작업이 무한이 연기되어서는 안된다.
    



### 스케줄링 시 고려 사항

- 선점형 스케줄링
    - 어떤 프로세스가 CPU를 할당받아 실행 중이여도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식
    - 장점
        - 특정 프로세스가 CPU를 독점할 수 없다
        
        → 대화형이나 시분할 시스템에 적합
        
    - 단점
        - 문맥 교환의 오버헤드가 많다
- 비 선점형 스케줄링
    - 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식
    - 장점
        - CPU 스케줄러의 작업량이 적고 문맥교환의 오버헤드가 적다
        
        → 일괄 작업 시스템에 사용함 (프린터)
        
    - 단점
        - 기다리는 프로세스가 많아 처리율이 떨어짐



### 프로세스 우선순위

- 커널 프로세스의 우선순위가 일반 프로세스보다 높다
- 시스템에는 다양한 우선순위의 프로세스가 공존하며 우선순위가 높은 프로세스가 CPU를 먼저 더 오래 차지
- 시스템에 따라 높은 숫자가 높은 우선순위를 나타내기도하고, 낮은 숫자가 높은 우선순위를 나타내기도함



### CPU 집중프로세스와 입출력 집중 프로세스

- CPU 집중 프로세스 (CPU BURST)
    - 수학 연산과 같이 CPU를 많이 사용하는 프로세스로 CPU 버스트가 많은 프로세스
- 입출력 집중 프로세스 (IO BURST)
    - 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스로 입출력 버스가 많은 프로세스

<img src="11-01\스크린샷_2022-03-28_오후_5.50.47.png" alt="스크린샷_2022-03-28_오후_5.50.47" style="zoom:33%;" />

<aside>
💡 입출력 집중 프로세스를 우선하여 처리하는게 대체적인 상황에선 효율적으로 대기시간을 줄일 수 있다.



- 전면 프로세스
    - GUI를 사용하는 운영체제에서 화면의 맨 앞에서 놓인 프로세스
    - 입출력 사용, 상호 작용 프로세스
- 후면 프로세스
    - 사용자와 상호작용이 없는 프로세스
    - 일괄작업 프로세스

→ 우선순위로는 전면 프로세스가 후면프로세스보다 더 우선된다



### 다중 큐

---

<img src="11-01\스크린샷_2022-03-30_오전_11.07.39.png" alt="스크린샷_2022-03-30_오전_11.07.39" style="zoom:33%;" />

- 프로세스의 중요도는 PCB에 표시되지만, 매번 CPU 스케줄러가 모든 PCB를 탐색하는건 비효율 적이기 때문에 다중큐 방식을 사용한다.

- 준비 상태의 다중 큐 (우선순위 순서)
    - 프로세스는 준비 상태의 들어올 때마다 자신의 우선순위에 해당하는 큐의 마지막에 삽입
    - CPU 스케줄러는 우선순위가 가장 높은 큐(0번 큐)의 맨 앞에 있는 프로세스 6에 CPU 할당

- 프로세스의 우선 순위를 배정하는 방석
    - 고정 우선순위 방식
        - 운양체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식
            - 우선순위가 작업중에 변하지 않기 때문에, 시스템의 변화에 대응이 어려워 효율이 상대적으로 떨어짐
    - 변동 우선순위 방식
        - 프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변하는 방식
            - 구현하기 어려우나, 시스템의 효율성을 높일 수 있음

- 대기 상태의 다중 큐
  
    ![스크린샷_2022-03-30_오전_11.14.18](11-01\스크린샷_2022-03-30_오전_11.14.18.png)
    
    - 시스템의 효율을 높이기 위해 대기 상태에서는 같은 입출력을 요구한 프로세스들끼리 모아놓음
    
     → 대기 상태의 프로세스들을 구분해 놓는 것으로 다음 작업시 효율을 높일 수 있음
    
- 다중 큐 비교
    - 준비 상태의 다중큐
        - 힌번에 프로세스를 한개를 꺼내어 CPU를 할당
    - 대기 상태의 다중큐
        - 여러개의 프로세스 제어블록을 동시에 꺼내어 준비상태로 옮김
        - 이 작업을 위해 인터럽트 벡터를 사용함



### 스케줄링 알고리즘

- **선점형, 비선점형 알고리즘**으로 나뉨
    - 선점형 : 이미 사용하고 있는 CPU 자원을 선점하여 작동하는 방식
    - 비선졈형 : 이미 사용하고 있는 CPU 자원을 선점하지 않고 대기후 작동하는 방식
    
    <img src="11-01\스크린샷_2022-03-30_오전_11.21.32.png" alt="스크린샷_2022-03-30_오전_11.21.32" style="zoom: 50%;" />
    
    최근에는 비선점형 보단 선점형을 위주로 사용함
    
- 스케줄링 알고리즘의 평가 기준
    - CPU 사용률
        - 전체 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법
        - 가장 이상적인 수치는 100% 이지만, 실제로는 여러가지 이유로 90%에도 못미침
    
    - 처리량
        - 단위 시간당 작업을 마친 프로세스의 수
        - 이 수치가 클수록 좋은 알고리즘
    
    <img src="11-01\스크린샷_2022-03-30_오전_11.33.19.png" alt="스크린샷_2022-03-30_오전_11.33.19" style="zoom:33%;" />
    
    대기, 응답, 실행, 반환 시간의 관계
    
    - 대기시간 : 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간
    - 응답시간 : 첫번째 출력 또는 반응이 나올때 걸리는 시간
    - 실행시간 : 프로세스 작업이 시작된 후 종료되기까지의 시간
    - 반환시간 : 사용한 모든 자원을 반환하는데 걸린 시간 (대기 시간 + 실행 시간)
      
        → 보통 처리량은 계산 하기 어렵기 때문에 **대기시간, 응답시간, 반환 시간**을 계산함 
        



## 비선점형 알고리즘

- CPU를 중간에 선점하여 가져갈 수 없는 알고리즘



### FCFS 스케줄링

<img src="11-01\스크린샷_2022-03-30_오전_11.37.36.png" alt="스크린샷_2022-03-30_오전_11.37.36" style="zoom: 50%;" />

- FCFS 스케줄링
    - 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식
    - 한 번 실행되면 그 프로세스가 끝나야만 다음 프로세스를 실행 할 수 있음
    - 큐가 하나라 모든 프로세스는 우선순위가 동일

- 성능
    - 프로세스 평균 대기시간 = (P1 대기시간 + P2 대기시간 + P3 대기시간)/  총 프로세스 갯수
      
        <img src="11-01\스크린샷_2022-03-30_오전_11.38.36.png" alt="스크린샷_2022-03-30_오전_11.38.36" style="zoom:50%;" />
        
        <aside>
        💡 대기시간 = 프로세스 시작시간 - 프로세스 도착시간
        → 평균 대기시간이 낮을 수록 효율적인 스케줄링 알고리즘이라 볼 수 있다.
        



### SJF 스케줄링

<img src="11-01\스크린샷_2022-04-04_오후_4.09.41.png" alt="스크린샷_2022-04-04_오후_4.09.41" style="zoom:33%;" />

- 준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU에 할당하는 비선점형 방식
- 최단 작업이 우선 스케줄링이라 함
- 호위 효과를 완화하여 시스템의 효율성을 높임

- 평가
    - 운영체제가 프로세스의 종료시간을 정확히 예측하기 어려움
    - 작업 시간이 길다는 이유만으로 계속 뒤로 밀려 공평성이 현저히 떨어짐 → 아사(starvation)

- 에이징(나이 먹기)
    - 아사(starvation) 현상의 완화 방법
    - 프로세스가 양보할 수 있는 상한선을 정하는 방식
    - 프로세스가 자신의 순서를 양보할때마다 나이를 한 살씩 먹어 최대 값까지만 양보하도록 규정하는것
    



### HRN(Highest Response Ratio Next) 스케줄링

<img src="11-01\스크린샷_2022-04-04_오후_4.12.45.png" alt="스크린샷_2022-04-04_오후_4.12.45" style="zoom:33%;" />

- SJF 스케줄링에서 발생하는 아사 현상을 해소하기 위해 만들어진 비선점형 알고리즘
- 최고 응답률 우선 스케줄링
- **서비스를 받기위해 기다린 시간 + CPU 사용시간 을 고려하여** 스케줄링을 하는 방식
  
    → **대기시간이 클수록 우선순위가 크다**
    
- 프로세스의 우선순위를 결정하는 기준

<img src="11-01\스크린샷_2022-04-04_오후_4.17.07.png" alt="스크린샷_2022-04-04_오후_4.17.07" style="zoom:50%;" />

- 평가
    - SJF와 비교하면 여러 프로세스의 CPU 할당율을 높였으나, 여전히 공평성이 위배되어 있다



## 선점형 알고리즘

- CPU를 중간에 선점해 갈 수 있는 알고리즘



### 라운드 로빈 스케줄링

- 대부분의 선점형 알고리즘에서 많이 쓰임

<img src="11-01\스크린샷_2022-04-04_오후_4.17.07.png" alt="스크린샷_2022-04-04_오후_4.17.07" style="zoom:50%;" />

- 한 프로세스가 할당받은 시간 동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
- 선점형 알고리즘 중 가장 단순하고 대표적인 방식
- 프로세스들이 작업을 완료할 때 까지 계속 순환하면서 실행

> 일정 시간만큼만 작동후 큐 맨뒤로 돌아가 대기하면서 완료될때 까지 순환하는 방식
선착순으로 진행하지만 일정시간 만큼만 작업후 나머지는 다음 순환에서 진행 한다
> 

<img src="11-01\스크린샷_2022-04-04_오후_4.19.01.png" alt="스크린샷_2022-04-04_오후_4.19.01" style="zoom:50%;" />

- 라운드로빈의 성능
    - 평균 대기시간은 67 / 3 = 22.33 밀리 세컨드
    - 일정시간 사용후 다음 프로세스에게 CPU를 넘겨주어야 하기 때문에 비선점형에서 발생한 불공정한 콘베이 효과가 줄어든다
    
- 타임 슬라이스 값 (프로세스가 할당받은 시간)
    - 큰 경우
        - 하나의 작업이 끝난후 다음 작업이 시작되는 것 처럼 동작해 FCFS 스케줄링과 다를바 없음
    - 작은 경우
        - 문맥 교환이 너무 자주 일어나 문맥 교환에 걸리는 시간이 실제 실행 시간보다 상대적으로 커지면서 많은 시간을 낭비할 수 있음

<aside>
💡 라운드 로빈 방식은 선점형이며, 일정 시간만 동작후 CPU를 다음큐에 있는 프로세스에게 넘겨야 하므로 공정한 편이다

타임 슬라이스 (한 작업에 제한한 시간) 이 높으면 FCSC와 다를바 없는 형식이 되고, 규정량을 작게 하면 문맥교환이 자주일어나 실행시간 < 저장, 불러오는 시간이 더 커지기 때문에 이를 규정하는것이 매우 중요하다



### SRT 우선 스케줄링

- STR(Shortest Remaining Time First) 스케줄링의 동작 방식
    - 기본적으로 라운드 로빈 스케줄링을 사용하지만 CPU를 할당받을 프로세스를 선택할 때 남아 있는 작업 시간이 가낭 적은 프로세스를 선택
    

<img src="11-01\스크린샷_2022-04-04_오후_4.29.46.png" alt="스크린샷_2022-04-04_오후_4.29.46" style="zoom:50%;" />

<img src="11-01\스크린샷_2022-04-04_오후_4.30.10.png" alt="스크린샷_2022-04-04_오후_4.30.10" style="zoom:50%;" />

- 평가
    - 현재 실행 중인 프로세스와 큐에 대기중인 프로세스의 남은시간을 주기적으로 계산하는 추가 작업과 더 적은 프로세스와 문맥교환을 해야하므로 SJF 에는 없는 작업이 추가된다

<aside>
💡 SRT 스케줄링 : SJF 방식과 비슷하게 남아있는 **대기시간을 예상하기 어려워** 사용하기 어려운 선점형 방식



### 우선순위 스케줄링

- 프로세스의 중요도에 따른 우선순위를 반영한 스케줄링 알고리즘
  
    <img src="11-01\스크린샷_2022-04-04_오후_4.32.45.png" alt="스크린샷_2022-04-04_오후_4.32.45" style="zoom: 50%;" />
    
    
    

<img src="11-01\스크린샷_2022-04-04_오후_4.33.05.png" alt="스크린샷_2022-04-04_오후_4.33.05" style="zoom:50%;" />

- 비선점형 선점형 방식 모두에게 적용가능

- 변동 우선순위
    - 일정 시간마다 우선순위가 변하며 일정 시간마다 우선순위를 새로 계산하고 이를 반영
      
        > 변동 우선순위에 경우 우선순위 반영을 위해 CPU 자원을 소모하므로 자주 사용할 경우 효율이 떨어진다 → 오버헤드 발생
        > 
- 고정 우선순위
    - 한 번 우선순위를 부여 받으면 종료될 때까지 우선순위가 고정



### 다단계 큐 스케줄링

- **우선순위에 따라 준비 큐를 여러 개** 사용하는 방식
- 프로세스는 OS로부터 부여 받은 우선순위에 따라 해당 우선순위에 큐에 삽임
- 우선순위는 고정형 우선순위 사용

<img src="11-01\스크린샷_2022-04-04_오후_4.36.32.png" alt="스크린샷_2022-04-04_오후_4.36.32" style="zoom:50%;" />

- 단점
    - 다른 비선점형에서 발견한 불공정한 콘베이 현상이 더 심하게 발생할 수 있다



### 다단계 피드백 큐 스케줄링 동작 방식

- 프로세스가 CPU를 할당 받아 실행 될때 마다 가변 타임슬라이스 기법으로 동작하는 방식
  
    <img src="11-01\스크린샷_2022-04-04_오후_4.40.24.png" alt="스크린샷_2022-04-04_오후_4.40.24" style="zoom:50%;" />
    
    > 오늘날 유닉스 운영체제에서 채낵한 스케줄링 방식
    > 
    
    <aside>
    💡 라운드로빈 방식이 가장 많이 사용되며 그 다음으로 다단계 피드백 큐 순으로 많이 사용된다
    
    
    

## 인터럽트

### 폴링

- 입출력을 요청하면 운영체제가 주기적으로 입출력장치를 직접 확인해서 처리하는 방식

> 비유를 하면 신호를 받지않고 직접 필요여부를 찾아서 이벤트를 발생시키는 방식
> 



### 인터럽트

- 이벤트 중심 방식과 마찬가지로 입출력 요청하고 입출력이 완료되면 이벤트를 발생시켜 알림

> 사전적의미 그대로 중간에 신호를 주어 이벤트를 발생시키는 방식
> 

- 동기적 인터럽트
    - 프로세스가 실행중인 명령어로 인해서 발생
    - 동기적 인터럽트의 종류
        - 프로그램상의 문제 때문에 발생하는 인터럽트 
        (ex : 메모리 영역에 접근하는 경우, 오버플로, 언더플로)
        - 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트 
        (ex : 컨트롤 + C)
        - 입출력장치 같은 주변장치의 조작으로 인해 발생한 인터럽트
        - 산술 연산 중 발생하는 인터럽트 (ex : 0 으로 나눔)
    
    > 소프트웨어실행과 관련하여 발생하는 인터럽트
    > 

- 비동기적 인터럽트
    - 하드디스크 읽기 오류, 메모리 불량과 같은 하드웨어적인 오류로 발생
    - 사용자가 직접 작동하는 키보드 인터럽트, 마우스 인터럽트 등이 있음
    
    > 프로그램의 실행과 관계 없이 **하드웨어적인 원인**으로 발생하는 인터럽트
    > 
    
- 인터럽트 처리과정
  
    <img src="11-01\스크린샷_2022-04-04_오후_5.06.45.png" alt="스크린샷_2022-04-04_오후_5.06.45" style="zoom:50%;" />
    
    - 인터럽트가 발생하면 그 인터럽트 번호와 그 번호에 붙어있는 함수가 작동된다
    → 인터럽트 벡터에 있는 인터럽트 핸들러 호출 (벡터의 인터럽트 부분이 0→ 1로 변경)
    
    - 커널 모드 : 운영체제와 관련된 커널 프로세스가 실행되는 상태
    - 사용자 모드 : 사용자 프로세스가 실행되는 상태
    - 이중 모드 : 운영체제가 커널 모드와 사용자 모드를 전환하며 일 처리를 하는것
        - 궁극적인 목적은 자원 보호에 있음