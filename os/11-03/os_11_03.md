# 프로세스 동기화

- 동기화 : 어느 순간의 작업, 상태 등을 일치 시키는것

- 프로세스 간 통신
- 공유 자원과 임계구역
- 임계구역 해결 방법
- 파일, 파이프, 소켓 프로그래밍



## 프로세스 간 통신



### 프로세스간 통신의 종류

<img src="11-03\스크린샷_2022-04-04_오후_5.45.35.png" alt="스크린샷_2022-04-04_오후_5.45.35" style="zoom:50%;" />

- 프로세스 내부 데이터 통신
    - 하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우의 통신
    - 프로세스 내부의 스레드는 전역 변수나 파일을 이용하여 데이터를 주고 받음
    
- 프로세스 간 데이터 통신
    - 같은 컴퓨터에 있는 여러 프로세스끼리 통신하는 경우
    - 공용 파일 또는 운영체제가 제공하는 파이프(DATA BUS)를 사용하여 통신
    
- 네트워크를 이용한 데이터 통신
    - 여러 컴퓨터가 네트워크로 연결되어 있을 때 통신
    - 소켓을 이용하여 데이터를 주고 받음

<aside>
💡 같은 컴퓨터 프로세스 끼리도 네트워크를 통한 소켓 통신이 가능하다 (127.0.0.1)
- 프로세스간 통신 방향에 따른 분류
    - 단방향
    - 반이중
    - 전이중

- 통신 구현 방식에 따른 분류
    - 대기가 있는 통신
        - 동기화를 지원하는 방식
    - 대기가 없는 통신
        - 동기화를 지원하지 않는 방식
    
- 프로세스 간 통신 방식
    - 데이터를 주거나 받는 동작, 쓰기 방식, 읽기 방식으로 간소화 가능하다
    



### 프로세스간 통신의 종류

<img src="11-03\스크린샷_2022-04-06_오전_11.09.15.png" alt="스크린샷_2022-04-06_오전_11.09.15" style="zoom: 33%;" />

전역변수를 이용한 양방향 통신

- 전역 변수를 이용한 통신
    - 공동으로 관리하는 메모리를 사용하여 데이터를 주고 받는것
    - 데이터를 보내는 쪽에선 전역변수나 파일에 값을 쓰고 데이터를 받는 쪽에서는 전역 변수의 값을 읽음
    

```cpp
int main(){
    int fd;
    char buf[5];

    fd = open('com.txt', O_RDWR);
    write(fd, "test", 5);
    read(fd, buf, 5);
    close(fd);
}
```

- 파일을 이용한 통신 (코드해석)
    - 파일을 OPEN, Write, Read, Close 4가지 방식을 거쳐 이용하는 통신 방법
        - 파일열기(OPEN)
            - 파일을 읽기위한 형태로 준비 (사전정보 탐색)
            - 파일이 열리면 그 파일에 접근할 수 있는 권한인 fd를 사용자에게 반환
            → 이떄 fd 변수에는 com.txt 파일에 대한 권한정보, 위치정보 등이 담겨 있다
        - 파일쓰기(Write)
            - write함수를 이용해 com.txt 파일에 test 문자열을 쓴다
        - 파일읽기(Read)
            - read함수를 이용해 com.txt 파일을 읽어 내용을 buf 변수에 저장
        - 파일닫기(Close)
            - open 통해 얻은 fd → com.txt 파일을 닫음
    

<img src="11-03\스크린샷_2022-04-06_오전_11.10.51.png" alt="스크린샷_2022-04-06_오전_11.10.51" style="zoom: 33%;" />

코드상에서 작성된 파일 통신은 프로세스에서 작동될 때 입출력 프로세스에게 요청하는 식으로 작동

- 파이프를 이용한 통신
  
    <img src="11-03\스크린샷_2022-04-06_오전_11.16.54.png" alt="스크린샷_2022-04-06_오전_11.16.54" style="zoom: 33%;" />
    
    - 운영체제가 제공하는 동기화 통신 방식
    - 전역변수와 마찬가지로 단방향 통신 이며, 양방향으로 이용하려면 2개의 파이프가 필요

- 소켓을 이용한 통신
  
    <img src="11-03\스크린샷_2022-04-06_오전_11.18.27.png" alt="스크린샷_2022-04-06_오전_11.18.27" style="zoom:33%;" />
    
    - 여러 컴퓨터에 이는 프로세스끼리 통신하는 방법
    - 통신하고자 하는 프로세스는 자신의 소켓과 상대의 소켓을 연결
    - 시스템에 있는 프로세스가 소켓을 바인딩한 후 소켓에 쓰기연산을 하면 데이터가 전송되고 읽기 연산을 하면 데이터를 받게 됨
    - 요약
      
      
        | 종류 | 운영체제 동기화 지원 | Open/Close() 사용 |
        | --- | --- | --- |
        | 전역 변수 | 동기화 지원 x(busy waiting 사용) | x |
        | 파일 | 동기화 지원 x(wait 함수 이용) | O |
        | 파이프 | O | O |
        | 소켓 | O | O |



## 공유 자원과 임계구역



### 공유 자원의 접근

- 공유 자원
    - 공유 자원은 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일을 말함
    - 공동으로 이용되기 때문에 누가 언제 데이터를 읽고 쓰느냐에 따라 결과가 달라질 수 있음
- 경쟁 조건
    - 2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황
    - 경쟁 조건이 발생하면 공유 자원 접근 순서에 따라 실행 결과가 달라질 수 있음
    

> 공유자원이 있으면 경쟁조건이 발생하고, 경쟁조건이 최악의 결과로 교착상태가 발생한다
폰노이만 구조는 교착상태의 문제가 발생하는걸 대비해야한다(알고리즘 등으로)
> 



### 임계구역

- 공유 자원 접근 순서에 따라 실행결과가 달라지는 프로그램의 영역
- 임계구역에선 프로세스들이 동시에 작업을 해선 안됨
- 어떤 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역 밖에서 그 프로세스가 나올때 까지 대기해야 들어갈 수 있음 (release 대기)



### 생산자-소비자 문제

<img src="11-03\스크린샷_2022-04-11_오후_4.14.58.png" alt="스크린샷_2022-04-11_오후_4.14.58" style="zoom:33%;" />

- 코드 및 실행 순서에 따른 결과
    - 생산자는 수를 증가시켜가며 물건을 채우고, 소비자는 생산자를 쫒아가며 물건을 소비
    - 생산자 코드와 소비자 코드가 동시에 실행되면 문제가 발생
    → 생산자 코드와 소비자 코드가 전역변수등에 접근하는 타이밍을 맞추기 어렵다
    → sum = sum +1; , sum = sum -1; 코드가 동시에 실행되면 순서에 따라 결과가 크게 달라지기 때문에 문제가 발생한다 (심할경우 오버플로우, 언더플로우등의 오류 발생)
    
    <aside>
    💡 이로 인해 운영체제는 임계구역에 작업을 할당하여, 원하는 순서에 작동되게 하여 문제를 해결한다
    
- **임계구역 해결 조건**
    - **상호 배제**
        - 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없는것
    - 한정 대기
        - 어떤 프로세스도 무한 대기가 되어선 안됨 
        (대기시간 존재 등의 조건 필요)
    - 진행의 융퉁성
        - 한 프로세스가 다른 프로세스의 진행을 방해해선 안됨



### 임계구역 해결 방법

```c
#include <stdio.h>

//C에선 bool 구조가 없기에 직접 구현해야함
typedef enum {false, true} boolean;
extern boolean lock = false;
extern int balance;

main(){
	while(lock == true);
	lock = true;
	balance = balance +10;
	lock = false;
}
```

> lock 이라는 전역변수를 통해 임계구역에 들어갔는지 구분하여, 임계구역에 벗어났을때 작업을 하는 구조
만일 임계구역에 누군가 진입해 있다면 아무런 작업을 하지않고 대기하는 방식
> 

→ 다만 위 방식도 동시에 접속하는 문제, 대기중에 무한루프를 돌면서 자원을 소비하는 문제가 발생한다

- lock1, lock2 로 나누어서 진행

```c
lock1 = false;
lock2 = false;

main(){
	while(lock2 == true);
	lock1 = true;
	balance = balance +10;
	lock1 = false;
}
```

```c
lock1 = false;
lock2 = false;

main(){
	while(lock1 == true);
	lock2 = true;
	balance = balance +10;
	lock2 = false;
}
```

> 위와 같은 경우 상호 배제 조건은 충족하지만, 두 프로세스가 타임아웃에 걸리게 되면 서로 lock이 걸려 무한대기 상태에 걸리는 문제가 발생한다
> 



### 피터슨 알고리즘



### 데커 알고리즘



### 세마포어(Semaphore)

---

- 임계구역에 진입하기 전에 스위치를 사용 중으로 놓고 임계구역으로 들어감
- 이후에 도착하는 프로세스는 앞의 프로세스가 작업을 마칠 때까지 기다림
- 프로세스가 작업을 마치면 다음 프로세스가 임계구역을 사용하라는 동기화 신호를 보냄

- **내부코드**
    - Semaphore(n) : 전역 변수 RS를 n으로 초기화, RS에는 현재 사용가능한 공유 자원의 수가 저장
    - P() : 잠금을 수행, RS가 0보다 크면(공유 자원이 1개이상 있다면), 1만큼 감소 시키고 임계구역에 진입, 작으면 커질떄 까지 대기
    - V() : 잠금 해제와 동기화를 같이 수행하는 코드로 RS 값을 1 증가시키고 세마포어에서 기다리는 프로세스에게 임계구역에 진입해도 된다는 wake_up 신호를 보냄
    

> 앞에 있던 알고리즘의 문제를 해결하지만, 세마포어 함수를 잘못사용한 경우 임계구역을 보호받을 수 없다
> 



### 모니터

---

- 세마포어의 문제접을 보완한 방식
- 시스템 호출과 같은 개념으로 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함, 이를 통해 자원을 보호하고 프로세스 간에 동기화를 시킴

- 작동원리
    - 모니터라는 큐를 만들어, 프로세스를 하나씩 쌓아서 작업하는 방식

- 예제코드

```java
monitor shared_balance{
	private:
		int balance = 10;
		boolean busy = false;
		condition mon;

	public:
		increase(int amount){
			if(busy == ture) mon.wait();
			busy = true;
			balance = balance + amount;
			mon.signal();
		}
}
```



## 파일, 파이프, 소켓프로그래밍



### 파일

- 순차파일
    - 아무리 큰 파일이라도 파일 내의 데이터는 개념적으로 한 줄로 저장됨
    → \n 등의 줄바꿈 문자를 넣어 한줄로 저장되는 식
    → 파일의 끝엔 \0 = end of file이 있다
    - 예시) 카세트 테이프, 마그네틱 테이프
    - 단점
        - 중간에 데이터를 읽기위해선 처음부터 일일이 읽어나가는 식으로 찾아야함

- 파일 기술자(File Descriptor)
    - open() 함수로 파일을 열면 파일 기술자가 정보(fd)를 얻음
    - 파일 기술자는 파일 접근 권한 외에 현재 파일의 어느 위치를 읽고 있는지에 대한 정보도 보관
    - 처음 파일이 열리면 파일 기술자는 맨 앞에 위치
    - 파일에서 파일 기술자는 단 하나, 읽기를 하던 쓰기를 하던 앞으로 전진함