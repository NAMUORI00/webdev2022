# 물리 메모리 관리



## 메모리 관리의 복잡성



### 메모리 주소

- 1Byte로 나뉜 메모리의 각 영역은 메모리 주소로 구분하는데 보통 0부터 시작
- CPU는 메모리에 있는 내용을 가져오거나 작업 결과를 메모리에 저장하기 위해 메모리 주소 레지스터를 사용

<img src="image/스크린샷_2022-04-27_오전_11.19.51.png" alt="스크린샷_2022-04-27_오전_11.19.51" style="zoom:67%;" />



### 메모리 관리의 복잡성

<img src="image/스크린샷_2022-04-27_오전_11.32.31.png" alt="스크린샷_2022-04-27_오전_11.32.31" style="zoom:50%;" />

- 메모리는 폰노이만 구조의 컴퓨터에서 유일한 작업 공간이며 모든 프로그램은 메모리에 올라와야 실행 가능
- 시분할 시스템에서는 운영체제를 포함한 모든 응용 프로그램이 메모리에 올라와 실 행되기 때문에 메모리메리 관리가 복잡



### 메모리 관리의 이중성

- 프로세스 입장에서는 메모리를 독차지하려 하고, 메모리 관리자 입장에서는 되도록 관리를 효율적으로 하고 싶어함

> 프로그램을 메모리에 작업을 하는 이유는 비용적 측면의 효율성을 위해서이다
> 



### 소스코드 번역과 실행

- 컴파일러 : 소스코드를 한꺼번에 번역하여 실행 (자바, C)
- 인터프리터 : 소스코드를 한줄씩 번역하여 실행 (자바스크립트, 파이썬)



### 메모리 관리자의 역할

- 메모리 관리자(MMU, Memory Managemant Unit)
    - 메모리 관리를 담당하는 하드웨어

<img src="image/스크린샷_2022-04-27_오전_11.39.57.png" alt="스크린샷_2022-04-27_오전_11.39.57" style="zoom: 33%;" />

- 메모리 관리자 작업
    - 가져오기 : 프로세스 데이터를 메모리로 로드
    - 배치 : 가져온 데이터를 메모리에 물리적 어디 위치에 올릴지 결정
    - 재배치 : 꽉 차있는 메모리에 새로운 프로세스를 로드하기 위해 오래된 프로세스를 정리

- 메모리 관리자 정책
    - 가져오기 정책
        - 프로세스가 필요로 하는 데이터를 언제 메모리를 결정하는 정책
    - 배치 정책
        - 가져온 프로세스를 메모리의 어떤 위치에 놓을지 결정하는 정책
    - 재배치 정책
        - 가득찬 메모리 내에 있는 어떤 프로세스를 내보낼지 결정하는 정책
        

<img src="image/스크린샷_2022-05-02_오후_4.03.52.png" alt="스크린샷_2022-05-02_오후_4.03.52" style="zoom: 33%;" />

- CPU의 비트
    - 한 번에 다룰 수 있는 데이터의 최대 크기
    - 32bit CPU는 한번에 다룰 수 있는 데이터의 최대 크기가 32bit
    - 32bit CPU 내의 레지스터 크기는 전부 32bit, 산술 논리 연산장치와 대역폭도 32bit

- 32bit CPU 메모리 크기
    - 표현할 수 있는 메모리 주소의 범위가 0~ 2^32-1, 총 갯수가 2^32
    - 16진수로 나타내면 00000000 ~ FFFFFFFF 총 크기는 약 4기가바이트(2^32)

- 64bit CPU 메모리 크기
    - 0~2^64-1번지 주소 공간 사용
    - 총 크기가 약 2^64바이트 약 1677716TB로 거의 제한없는 메모리 사용가능

- 물리 주소 공간과 논리 주소 공간
    - 물리 주소 공간 : 하드웨어 입장에서 바라본 주소 공간으로 컴퓨터마다 크기가 다름
    - 논리 주소 공간 : 사용자 입장에서 바라본 주소 공간

- 32비트 64비트 차이

<img src="image/스크린샷_2022-05-02_오후_4.26.54.png" alt="스크린샷_2022-05-02_오후_4.26.54" style="zoom:50%;" />



### 절대주소 상대주소

- 단순 메모리 구조
  
    <img src="image/스크린샷_2022-05-02_오후_4.31.51.png" alt="스크린샷_2022-05-02_오후_4.31.51" style="zoom:50%;" />
    
    - 한 번에 한 가지 일만 처리하는 일괄 처리 시스템에서 볼 수 있음
    - 메모리를 운영체제 영역과 사용자 영역을 나누어 관리
    
    <img src="image/스크린샷_2022-05-02_오후_4.40.19.png" alt="스크린샷_2022-05-02_오후_4.40.19" style="zoom:50%;" />
    
- 경계 레지스터
    - 운영체제 영역과 사용자 영역 경계 지점에 주소를 가진 레지스터
    - CPU내에 있는 경계 레리스터가 사용자 영역이 운영체제 영역으로 침범하는 것을 막음
    - 메모리 관리자는 사용자가 작업을 요청할 때 마다 경계 레지스터의 값을 어너나는지 검사, 경계 레지스터의 임계를 벗어나는 작업을 요청하는 경우 프로세스 종료

- 절대 주소
    - 실제 물리 주소를 가리키는 주소
    - 메모리 주소 레지스터가 사용하는 주소
    - 컴퓨터에 꼳힌 램 메모리의 실제 주소

- 상대 주소
    - 사용자 영역이 시작되는 번지를 0번지로 변경하여 사용하는 주소
    - 사용자 프로세스 입장에서 바라본 주소
    - 절대주소와 관계없이 항상 0번지 주소부터 시작
    - 프로세스 입장에서 상대주소가 사용할 수 없는 영역의 위치를 알 필요가 없고, 주소가 항상 0번지 부터 시작해서 사용이 편리

- 절대 주소, 상대 주소의 차이
    - 논리 주소 공간은 상대 주소를 사용하는 공간
    - 물리 주소 공간은 절대주소를 사용하는 공간

<img src="image/스크린샷_2022-05-02_오후_4.41.55.png" alt="스크린샷_2022-05-02_오후_4.41.55" style="zoom:50%;" />

| 구현 | 절대주소 | 상대주소 |
| --- | --- | --- |
| 관점 | 메모리 관리자 | 사용자 프로세스 |
| 주소시작 | 물리 주소 0부터 | 물리주소와 관계 없이 항상 0번지 부터시작 |
| 주소 공간 | 물리 주소(실제) | 논리 주소 공간 |
|  |  |  |

> 상대주소를 절대 주소로 변환하는 과정
> 

<img src="image/스크린샷_2022-05-02_오후_4.51.33.png" alt="스크린샷_2022-05-02_오후_4.51.33" style="zoom:50%;" />

- 메모리 접근 시 상대 주소를 사용하면 절대 주소로 변환해야 함
- 메모리 관리자는 사용자 프로세스가 상대주소를 사용하여 메모리에 접근할 때마다 상대 주소값에 재배치 레지스터 값을 더해주고 주소를 구함
- 재배치 레지스터 : 주소 변환의 기본이 되는 주소값을 가진 레지스터, 메모리에서 사용자 영역의 시작 주소값이 저장

<img src="image/스크린샷_2022-05-02_오후_4.48.28.png" alt="스크린샷_2022-05-02_오후_4.48.28" style="zoom:50%;" />

- **메모리 오버레이 (Memory Overlay)**
    - 프로그램의 크기가 실제 메모리 보다 클 때 전체 프록그램을  메모리에 가져오는 대신 적당한 크키로 잘라서 가져오는 기법
    
    <img src="image/스크린샷_2022-05-02_오후_4.53.46.png" alt="스크린샷_2022-05-02_오후_4.53.46" style="zoom:50%;" />
    
    - 작동 방식
        - 프로그램이 실행되면 필요한 모듈만 메모리에 가져와서 실행
    - 의미
        - 한정된 메모리에서 메모리보다 큰 프로그램 실행 가능
        - 프로그램 전체가 아니라 일부문 메모리에 올라와도 실행 가능

- **스왑 (Swap)**
  
    <img src="image/스크린샷_2022-05-02_오후_5.06.41.png" alt="스크린샷_2022-05-02_오후_5.06.41" style="zoom:50%;" />
    
    - 메모리가 모자라 쫒겨난 프로세스를 저장장치의 특별하 공간에 모아두는 영역
    - 메모리에서 쫒겨났다가 다시 돌아가는 데이터가 머무는 곳이기 때문에 저장장치는 장소만 빌려주고 메모리 관리자가 관리 한다
    - 사용자는 실제 메모리의 크기와 스왑 영역의 크기를 합쳐서 전체 메모리로 인식하고 사용

- **스왑인(Swap in), 스왑아웃(Swap out)**
    - 스왑인 : 스왑 영역에서 메모리로 데이터를 가져오는 작업
    - 스왑아웃 : 메모리에서 스왑영역으로 데이터를 내보내는 작업



### 메모리 분할 방식

<img src="image/스크린샷_2022-05-02_오후_5.15.03.png" alt="스크린샷_2022-05-02_오후_5.15.03" style="zoom: 50%;" />

paging(Fixed Partition), Segmentation(Dynamic Partition)

- 메모리에 여러 개의 프로세스를 배치하는 방법
    - 가변 분할 방식 : 프로세스의 크기에 따라 메모리를 나누는 방식
        - 크기에 제약이 없기 떄문에 할당시 편하게 원하는 크기로 할당
        - 장점 : 프로세스를 한 덩어리로 처리하여 하나의 프로세스를 연속된 공간에 배치
        - 단점 : 비어 있는 공간을 하나로 합쳐야 하며, 이 과정에서 다른 프로세스의 자리도 옴ㄹ겨야 하므로 메모리 관리가 복잡해짐
    
    - 고정 분할 방식 : 프로세스의 크기에 관계 없이 일정한 같은 크기로 메모리를 나누는 방식
        - 일정 크기의 파티션으로 나누어져 할당시 파티션 단위로 할당
        - 장점 : 메모리를 일정한 크기로 나누어 관리하기 때문에 메모리 관리가 수월 (가변 분할 방식의 메모리 통합 과정을 필요로 하지 않음)
        - 단점 : 파티션 별로 쓸모 없는 공간으로 인해 메모리 낭비가 발생 할 수 있음

- **메모리 분할 방식 구현**
  
    <img src="image/스크린샷_2022-05-02_오후_5.17.45.png" alt="스크린샷_2022-05-02_오후_5.17.45" style="zoom:50%;" />
    
    - 가변 분할 방식
        - 프로세스 크기에 맞게 메모리가 분할
        - 메모리의 영역이 각각 다름
        - 연속 메모리 할당
    
    - 고정 분할 방식
        - 프로세스의 크키에 관계 없이 메모리가 같은 크기로 나뉨
        - 큰 프로세스가 메모리에 올라오면 여러 조각으로 나누어 배치
        

- 가변 분할 방식과 외부 단편화
  
    <img src="image/스크린샷_2022-05-02_오후_5.40.42.png" alt="스크린샷_2022-05-02_오후_5.40.42" style="zoom:50%;" />
    
    - 프로세스 ABCDE를 순서대로 배치 후에 BD가 종료 되면 18, 17kb의 빈 공간이 생김
    - 이후 18kb 이상의 큰프로세스를 처리할때 공간이 없어서 처리를 못하게 됨
    → 이때의 작은 빈공간들을 외부 단편화라 함
    
- 외부 단편화 해결
    - 메모리 배치 방식 : 작은 조각이 발생하지 않도록 프로세스를 배치하는 것
    - 조각 모음 : 조각이 발생했을 때 작은 조각들을 모아서 하나의 큰 덩어리로 만드는 작업

- 메모리 배치 방식
  
    <img src="image/스크린샷_2022-05-02_오후_5.46.15.png" alt="스크린샷_2022-05-02_오후_5.46.15" style="zoom:50%;" />
    
    - 최초 배치
        - 프로세스를 메모리의 빈 공간에 배치할 때 메모리에서 적재 가능한 공간을 순서대로 찾다가 첫 번째로 발견한 공간에 프로세스를 배치하는 방법
    - 최적 배치
        - 메모리의 빈 공간을 모두 확인한 후 적당한 크기 가운데 가장 작은 공간에 프로세스를 배치하는 방법
    - 최악 배치
        - 빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스를 배치하는 방법
    
    - 메모리 배치 비교
        - 최초 배치 : 단순함, 빈공간을 찾아다닐 필요 없음
        - 최적 배치 : 빈 공간을 모두 확인하는 부가적인 작업이 필요함
        - 최악 배치 : 프로세스를 배치하고 남은 공간이 크기 때문에 쓸모가 있음
        빈 공간의 크기가 클 때는 효과적이지만, 빈 공간의 크기가 점점 줄어들면 최적 배치 처럼 작은 조각을 만들어냄
    
    - 조각모음
      
        <img src="image/스크린샷_2022-05-04_오전_11.22.55.png" alt="스크린샷_2022-05-04_오전_11.22.55" style="zoom:50%;" />
        
        - 이미 배치된 프로세스를 옆으로 옮겨 빈 공간들을 하나의 큰덩어리로 만드는 작업
        



### 고정 분할 방식의 자리 배정

<img src="image/스크린샷_2022-05-04_오전_11.23.49.png" alt="스크린샷_2022-05-04_오전_11.23.49" style="zoom:50%;" />

일상생활 속 일식집을 예시로 들었을때

- 고정 분할 방식의 프로세스 배치
  
    <img src="image/스크린샷_2022-05-04_오전_11.25.59.png" alt="스크린샷_2022-05-04_오전_11.25.59" style="zoom:50%;" />
    
    - 분할된 크기는 20kb이므로 40kb인 프로세스 A는 프로세스 A1과 A2로 나뉘어 메모리에 할당
    - 30KB인 프로세스 C는 프로세스 C1, C2로 나뉘는데, 메모리에 남는 공간이 없으므로 C2는 스왑 영역으로 옮겨짐
    
- 고정 분할 방식과 내부 단편화
    - 각 메모리 조각에 프로세스를 배치하고 공간이 남는 현상

- 가변 분할, 고정 분할 방식 비교
  
    <img src="image/스크린샷_2022-05-04_오전_11.30.13.png" alt="스크린샷_2022-05-04_오전_11.30.13" style="zoom:50%;" />

### 버디 시스템

- 작동방식
    1. 프로세스 크기에 맞게 메모리를 1/2로 자르고 프로세스를 메모리에 배치
    2. 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어감
    3. 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만듦
       
        <img src="image/스크린샷_2022-05-04_오전_11.32.48.png" alt="스크린샷_2022-05-04_오전_11.32.48" style="zoom:50%;" />
        
        버디 시스템의 메모리 분할 예시
        
        - 일식집을 예시로 들었을떄
          
            <img src="image/스크린샷_2022-05-04_오전_11.33.29.png" alt="스크린샷_2022-05-04_오전_11.33.29" style="zoom:50%;" />
            
            ![스크린샷_2022-05-04_오전_11.34.52](image/스크린샷_2022-05-04_오전_11.34.52.png)
            
            <img src="image/스크린샷_2022-05-04_오전_11.35.32.png" alt="스크린샷_2022-05-04_오전_11.35.32" style="zoom:50%;" />
            
            > 일단 클땐 공간을 1/2로 자르는걸 반복해 최적의 공간이 나올때까지 반복한 후 배치하는 방식이버디 시스템이라 볼 수 있다
            > 
            
        - 특징
            - 가변 분할 방식처럼 메모리가 프로세스 크기대로 나뉨
            - 고정 분할 방식처럼 하나의 구역에 따른 프로세스가 들어갈 수 없고, 메모리의 한 구역 내부에 조각이 생겨 내부 단편화가 발생
            - 비슷한 크기의 조각이 서로 모여 작은 조각을 통합하여 큰 조각을 만들기 쉬움
        
