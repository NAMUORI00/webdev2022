# 프로세스



## 프로세스와 스레드

1. 프로세스 개요
2. 프로제스 제어 블록과 문맥 교환
3. 프로세스의 연산
4. 스레드
5. 동적할당 영역과 스레드



### 프로세스의 개념

- 프로그램
    - 저장장치에 저장되어 있는 정적인 상태
- 프로세스
    - 실행을 위해 메모리에 올라온 동적인 상태



### 프로그램에서 프로세스로의 전환

**프로세스 제어 블록(PCB) : 작업 지시서**

- 프로그램이 프로세스가 되었다는 것은 운영체제로부터 프로세스 제어 블록을 받았다는 의미이며, 운영체제 영역에 생성됨 프로세스 종료 시 프로세스 제어 블록 폐기됨

<img src="C:\Users\rladb\Downloads\Export-4e95e955-37a7-4799-96f6-5ae003062651\10-27\스크린샷_2022-03-16_오전_11.41.31.png" alt="스크린샷_2022-03-16_오전_11.41.31" style="zoom: 33%;" />

- 프로세스 제어 블록
    - 운영체제가 해당 프로세스를 위해 관리하는 자료 구조
    - 내용
        - 프로세스 구분자 : 각 프로세스를 구분하는 구분자
        - 메모리 관련 정보 : 프로세스의 메모리 위치 정보
        - 각종 중간값 : 프로세스가 사용했던 중간값
        



### 프로세스의 상태

<img src="C:\Users\rladb\Downloads\Export-4e95e955-37a7-4799-96f6-5ae003062651\10-27\스크린샷_2022-03-21_오후_4.07.08.png" alt="스크린샷_2022-03-21_오후_4.07.08" style="zoom:33%;" />

- 프로세스의 다섯가지 상태
    - 생성 상태 : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태
    →프로세스 제어블록이 생성된 상태
    - 준비 상태 : 생성된 프로세스가 CPU를 얻을 때 까지 기다리는 상태
    → 인터럽트의 타임아웃을 통해 되돌아감 
    (타임아웃 : 시간내로 작업을 못끝냈을 때 준비상태로 돌아가는 것)
    - 실행 상태 : 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태 
    → 디스패처가 처리 
    (디스패치 : 준비상태의 프로세스 하나를 골라 실행 상태로 바꾸는 스케줄러)
    - 완료 상태 : 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 진입하는 상태
      
        → 프로세스 제어 블록이 사라진 상태
        
        - 대기상태(Wait or Block) : 실행 상태에 있는 프로세스가 입출력을 요청 하였을 때, 입출력이 완료될때까지 기다리는 상태
        → 입출력 완료시 준비상태로 이동

<aside>
💡 프로세스의 상태는 넓게 보면 7가지 상태가 될 수 있고, 5가지, 4가지 상태로도 볼 수 있다



<img src="C:\Users\rladb\Downloads\Export-4e95e955-37a7-4799-96f6-5ae003062651\10-27\스크린샷_2022-03-21_오후_4.45.13.png" alt="스크린샷_2022-03-21_오후_4.45.13" style="zoom:33%;" />

- 프로세스의 2가지 상태
  - 휴식 상태 (pause status)
      - 프로세스가 작업을 일시적으로 쉬고 있는 상태
      - 유닉스에서 프로그램을 실행하는 도중에 Ctrl + Z 키를 누르면 진입할 수 있음
      
      ```jsx
      root@ubuntu : `$ sleep 100
      [1]+ Stopped
      ```
      
  - 보류 상태 (suspend status)
      - 프로세스 프로세스가 메모리에서 잠시 쫒겨난 상태
      - 프로세스는 다음과 같은 경우에 보류 상태가 됨
          - 메모리가 꽉차서 일부 프로세스를 메모리 밖으로 보낼 때
          - 프로그램에 오류가 있어서 실행을 미뤄야 할 때
          - 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
          - 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫒아내도 문제가 없을 때
          - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때



## 프로세스 제어블로과 문맥 교환



### 프로세스 제어블록

- 프로세스 제어블록 구성
    - 프로세스 제어블록(PCB)
        - 프로세스를 실행하는 데 필요한 정보를 보관하는 자료구조
        - 프로세스는 고유의 프로세스 제어 블록을 가짐
        - 프로세스 생성 시 만들어지며, 프로세스가 실행을 완료하면 폐기

| 포인터 / 프로세스상태 |
| --- |
| 프로세스 구분자 |
| 프로그램 카운터 |
| 프로세스 우선순위 |
| 각종 레지스터 정보 |
| 메모리 관리 정보 |
| 할당된 자원 정보 |
| 계정 정보 |
| PPID와 CPID |
| .... |



<img src="C:\Users\rladb\Downloads\Export-4e95e955-37a7-4799-96f6-5ae003062651\10-27\스크린샷_2022-03-21_오후_5.35.12.png" alt="스크린샷_2022-03-21_오후_5.35.12" style="zoom: 33%;" />

- 포인터
    - 대기 상태에서는 같은 입출력을 요구한 프로세스끼리 연결할 때 포인터 사용
      
        <img src="C:\Users\rladb\Downloads\Export-4e95e955-37a7-4799-96f6-5ae003062651\10-27\스크린샷_2022-03-21_오후_5.36.14.png" alt="스크린샷_2022-03-21_오후_5.36.14" style="zoom: 33%;" />
    



### 문맥교환

<img src="C:\Users\rladb\Downloads\Export-4e95e955-37a7-4799-96f6-5ae003062651\10-27\스크린샷_2022-03-21_오후_5.42.43.png" alt="스크린샷_2022-03-21_오후_5.42.43" style="zoom: 50%;" />

- 문맥교환의 의미
    - CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업
    - 실행 상태에서 나가는 프로세스 제어 블록에는 지금까지의 작업 내용을 저장하고 반대로 실행 상태로 들어오는 프로세스 제어 블록의 내용으로 CPU가 다시 세팅

<aside>
💡 요리작업의 전환으로 비유하면 아래와 같다



- [ ]  일련번호 #14
- [ ]  테이블번호: 2
- [ ]  전체인원 : 2
- [ ]  코스 : A
- [x]  수프 : 양파
- [ ]  등심 : 미디엄
- [ ]  녹차

→ 요리 작업 전환→

- [ ]  일련번호 #13
- [ ]  테이블번호: 2
- [x]  수프 : 토마토
- [ ]  전체인원 : 2
- [ ]  코스 : B
- [x]  새우튀김 : 바삭하게
- [ ]  과일



## 프로세스의 연산



### 프로세스의 구조

|  코드영역   | main(){    int a=2, b = 3;    printf(”a + b = : %d”, a+b);    exit(); } | 읽기 전용 |
| :---------: | ------------------------------------------------------------ | --------- |
| 데이터 영역 | int a = 2, b = 3;                                            | 읽기/쓰기 |
|  스택 영역  | return address 180                                           | 숨김 영역 |



- 코드영역
    - 프로그램의 본문이 기술된 곳으로 텍스트 영역 이라고도 함.
    - 자기 자신을 수정하는 프로그램은 없기 때문에 읽기 전용으로 처리 함
- 데이터 영역
    - 코드 실행하는데 사용되는 변수나 파일 등의 데이터를 모아놓은 곳
    - 변하는 값이기 때문에 읽기/쓰기 로 처리됨
- 스택 영역
    - 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳
    - 프로세스 내에서 Function Call 함수를 수행하는데 원래 프로그램으로 되돌아올 위치를 이 영역에 저장
    - 운영체제가 사용자의 프로세스를 작동하기 위해 유지하는 영역으로 숨겨진 상태를 유지함



### 프로세스의 생성과 복사

- fork() 시스템 호출(system call)의 개념
    - 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수
    - 실행 중인 프로세스와 똑같은 프로세스가 하나 더 만들어짐
    
    <aside>
    💡 fork()를 실행한 프로세스는 부모프로세스, 생겨난 복사 프로세스는 자식 프로세스의 관계를 가짐
    
    
    
- 장점
    - 프로세스 생성 속도가 빠름
    - 추가 작업 없이 자원을 상속할 수 있음
    - 시스템 관리를 효율적으로 할 수 있음

- exec() 시스템 호출(system call)의 개념
    - 기존의 프로세스를 새로운 프로세스로 전환하는 함수
        - fork() : 새로운 프로세스를 복사하는 시스템 호출
        - exec() : 프로세스는 그대로 둔 채 내용만 바꾸는 시스템 호출



### 프로세스의 계층 구조

<img src="C:\Users\rladb\Downloads\Export-4e95e955-37a7-4799-96f6-5ae003062651\10-27\스크린샷_2022-03-23_오전_11.06.57.png" alt="스크린샷_2022-03-23_오전_11.06.57" style="zoom: 33%;" />

- 유닉스의 프로세스 계층 구조
    - 유닉스의 모든 프로세스는 init 프로세스의 자식이 되어 트리 구조를 이루고 있다
    
- 프로세스 계층 구조의 장점
    - 여러 작업을 동시에 처리할 수 있다.
      
        <img src="C:\Users\rladb\Downloads\Export-4e95e955-37a7-4799-96f6-5ae003062651\10-27\스크린샷_2022-03-23_오전_11.15.05.png" alt="스크린샷_2022-03-23_오전_11.15.05" style="zoom:33%;" />
        
        예) login 프로세스는 1명만 처리가 가능한데, 이때 fork를 이용하여 login 프로세스를 여러 개 만들어 각 요청 사용자에게 나누어 주면 새로운 사용자가 요청할때마다 작업을 동시에 처리 가능
        
    
    <aside>
    💡 고아(미아) 프로세스 : 부모 프로세스가 먼저 종료되거나, 자원회수 이전에 자식프로세스가 비 정상적으로 종료 되었을때 자원이 그대로 남아있는 프로세스
    → 이를 방지하기위해 exit(), return()등의 작업 종료를 알리는 함수를 사용해야함