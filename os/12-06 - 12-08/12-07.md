# 가상 메모리의 기초



## 가상 메모리 시스템



### 가상 메모리 개념

- **물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술**
- 가상 메모리를 이용하면 프로세스는 운영체제가 어디에 있는지, 물리 메모리의 크기가 어느 정도인지 신경 쓰지 않고 메모리를 마음대로 사용할 수 있음

- 가상메모리 필요성 예시
    - 주방 규모를 고려한 레시피 개발의 어려움
        - 새로운 레시피를 개발할 때 요리사가 주방의 크기까지 고려해야 한다면 제약 사항이 너무 많음
          
            <img src="image\스크린샷_2022-05-09_오후_4.10.08.png" alt="스크린샷_2022-05-09_오후_4.10.08" style="zoom:50%;" />



### 가상 메모리 구성

<img src="image\스크린샷_2022-05-09_오후_4.10.37.png" alt="스크린샷_2022-05-09_오후_4.10.37" style="zoom:50%;" />

- 크게 프로세스가 바라보는 메모리 영역, 메모리 관리자가 바라보는 메모리영역 2가지로 나뉨
- 가상 메모리에서 메모리 관리자는 물리 메모리의 부족한 부분을 스왑 영역으로 보충



### 가상 메모리 크기

<img src="image\스크린샷_2022-05-09_오후_4.18.27.png" alt="스크린샷_2022-05-09_오후_4.18.27" style="zoom:50%;" />



### 동적 주소 변환

- 가상 주소를 실제 메모리의 물리 주소로 변환
- 동적 주소 변환을 거치면 프로세스가 아무 제약없이 사용자의 데이터를 물리 메모리에 배치할 수 있음

> 절대주소의 대비 되는 주소는 상대주소 이지만, 가상 주소는 상대주소를 이용할뿐 같은 개념이 아니다
> 



### 가상 메모리의 메모리 분할 방식

<img src="image\스크린샷_2022-05-09_오후_4.21.30.png" alt="스크린샷_2022-05-09_오후_4.21.30" style="zoom:50%;" />

- 가변 분할 방식을 이용한 세그멘테이션, 고정 분할 방식을 이용한 페이징 기법 두가지 있음
- 세그멘테이션은 외부 단편화 등의 문제 때문에 잘 사용되지 않음
- 페이징 기법은 페이지 관리에 어려움이 있음
- 가상 메모리 시스템에선 이 두가지를 혼용하여 단점을 보완한 기법을 사용



### 메모리 매핑 테이블(MMT)

<img src="image\스크린샷_2022-05-09_오후_4.31.14.png" alt="스크린샷_2022-05-09_오후_4.31.14" style="zoom:50%;" />

- 가상 메모리 시스템에서 메모리 관리자MMU는 가상 주소와 물리 주소를 일대일 매핑 테이블로 관리



## 페이징 기법

<img src="image\스크린샷_2022-05-09_오후_4.39.39.png" alt="스크린샷_2022-05-09_오후_4.39.39" style="zoom:50%;" />

- 고정 분할 방식을 이용한 메모리 분할 관리 기법
- 물리 주소 공간을 같은 크기로 나누어 사용
- 가상 주소는 프로세스 입장에서 바라본 메모리 공간으로 항상 0번지 부터 시작
- 페지이, 프레임
    - 가상 주소의 각 분할된 영역을 페이지라고 함, 번호를 붙여 관리
    - 물리 메모리의 각 영역은 가상주소의 페이지와 구분하기 위해 프레임이라고 함
    - 페이지와 프레임은 크기가 같기 때문에, 페이지는 어떤 프레임에도 배치 될 수 있음
    - 페이지 테이블에 invaild는 해당 페이지가 스왑 영역에 있다는 의미
    



### 프로세스 내용 읽기, 주소 변환 과정

<img src="image\스크린샷_2022-05-09_오후_4.44.29.png" alt="스크린샷_2022-05-09_오후_4.44.29" style="zoom:50%;" />

1. 가상 주소 30번지가 어느 페이지에 있는지 찾음
2. 페이지 테이블의 3으로 가서 해당 페이지가 프레임 1에 있음
3. 최종적으로 물리 메모리 프레임 1의 0번째 위치에 접근 (이때 주소가 주소 30번지의 물리주소)
   
    <img src="image\스크린샷_2022-05-09_오후_4.46.53.png" alt="스크린샷_2022-05-09_오후_4.46.53" style="zoom:50%;" />
    
    
    
    ### 정형화된 주소 변환
    
    - 페이징 기법에서는 가상주소를 VA= <P, D> 로 표현
        - VA : 가상주소
        - P : 페이지
        - D : 페이지의 처음 위치에서 해당 주소까지의 거리(offset)
    - 페이징 기법에서의 주소 변환은 VA = (P,D)로 물리주소 PA = <F, D>로 변환 하는것
        - PA : 물리 메모리 주소를 가리키는 용어, 물리 주소 또는 설계 주소
        - F : 프레임
        - D : 프레임의 처음 위치에서 해당 주소까지의 거리(offset)
    
    > D를 오프셋(변위)로 정의함
    > 
    
    
    
    ### 페이징 기법의 주소 변환
    
    <img src="image\스크린샷_2022-05-09_오후_4.52.31.png" alt="스크린샷_2022-05-09_오후_4.52.31" style="zoom:50%;" />
    
    - VA =<P,D> → PA = <F,D>
    - 페이지 테이블을 사용하여 P 는 F로 바꾸고 D는 변경 없이 그대로 적용
    - D는 그대로 사용할수 있는 이유는 페이지와 프레임 크기를 똑같이 적용하여 나누었기 때문



### 페이지 크기가 다양한 경우 가상 주소를 변환하는 공식

<img src="image\스크린샷_2022-05-09_오후_4.53.41.png" alt="스크린샷_2022-05-09_오후_4.53.41" style="zoom:50%;" />

한 페이지의 크기가 10B인 가상 메모리 시스템에서 가상 주소 32번지

- P=3(32/10의 몫)
- D=2(32/10의 나머지)

한 페이지의 크기가 512B인 시스템에서 가상 주소 2049번지

- P=4(2049/512의 몫)
- D=1(2049/512의 나머지)



### 16비트 CPU 컴퓨터에서 한페이지 크기가 2^10B 일 때 페이징 시스템

<img src="image\스크린샷_2022-05-09_오후_4.54.39.png" alt="스크린샷_2022-05-09_오후_4.54.39" style="zoom:50%;" />

<img src="image\스크린샷_2022-05-09_오후_4.56.52.png" alt="스크린샷_2022-05-09_오후_4.56.52" style="zoom:50%;" />

<img src="image\스크린샷_2022-05-09_오후_4.57.23.png" alt="스크린샷_2022-05-09_오후_4.57.23" style="zoom:50%;" />



### 다수의 프로세스가 있는 페이징 시스템

<img src="image\스크린샷_2022-05-09_오후_5.05.01.png" alt="스크린샷_2022-05-09_오후_5.05.01" style="zoom:50%;" />

- 한번에 실행 하는 프로세스 수가 많으면 페이지 테이블의 크기가 같이 커지고, 이에 따라 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어듬
- **페이지 테이블 크기를 적정하게 유지하는 것이 페이지 테이블 관리의 핵심**



### 물리 메모리 내 페이지 테이블 구조

<img src="image\스크린샷_2022-05-09_오후_5.11.09.png" alt="스크린샷_2022-05-09_오후_5.11.09" style="zoom:50%;" />

- 물리 메모리의 크기가 작을 때는 프로세스 스왑 영역으로 옮겨지는 것이 아니라 페이지 테이블의 일부도 스왑 영역으로 옮겨짐
- 각 페이지 테이블의 시작 주소는 페이지 테이블 기준 레지스터에 보관



